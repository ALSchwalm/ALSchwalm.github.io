<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Security Through Obscurity</title><description>On reverse engineering, programming, and maybe some other stuff.</description><link>https://alschwalm.com/blog/static/</link><generator>Ghost 0.11</generator><lastBuildDate>Tue, 07 Mar 2017 00:23:18 GMT</lastBuildDate><atom:link href="https://alschwalm.com/blog/static/rss/index.xml" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Exploring Dynamic Dispatch in Rust</title><description>&lt;p&gt;Let me preface this by saying that I am a novice in the world of rust (though I'm liking things so far!), so if I make technical mistakes please let me know and I will try to correct them. With that out of the way, lets get started.&lt;/p&gt;

&lt;p&gt;My real&lt;/p&gt;</description><link>https://alschwalm.com/blog/static/2017/03/07/exploring-dynamic-dispatch-in-rust/</link><guid isPermaLink="false">1d83f50c-4ce9-4919-ba4f-151053a951f5</guid><dc:creator>Adam Schwalm</dc:creator><pubDate>Tue, 07 Mar 2017 00:17:27 GMT</pubDate><content:encoded>&lt;p&gt;Let me preface this by saying that I am a novice in the world of rust (though I'm liking things so far!), so if I make technical mistakes please let me know and I will try to correct them. With that out of the way, lets get started.&lt;/p&gt;

&lt;p&gt;My real motivation for taking a closer look at dynamic dispatch can be seen in the following code snippet. Suppose I want to create a struct &lt;code&gt;CloningLab&lt;/code&gt; that contains a vector of trait objects (in this case, &lt;code&gt;Mammal&lt;/code&gt;):&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/b43986e11db2d864ee9adf090dedfa45.js"&gt;&lt;/script&gt;

&lt;p&gt;This works fine. You can iterate over the vector of subjects and call &lt;code&gt;run&lt;/code&gt; or &lt;code&gt;walk&lt;/code&gt; as you would expect. However, things break down when you try to add an additional trait to the trait object bounds like:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/d56ccd574a3b517ad20a7c6e5dc3f3f8.js"&gt;&lt;/script&gt;

&lt;p&gt;This fails with the the following error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error[E0225]: only the builtin traits can be used as closure or object bounds
 --&amp;gt; test1.rs:3:32
  |
3 |     subjects: Vec&amp;lt;Box&amp;lt;Mammal + Clone&amp;gt;&amp;gt;,
  |                                ^^^^^ non-builtin trait used as bounds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And I found this surprising. In my mind, a trait object with multiple bounds would be analogous to multiple inheritance in C++. I would expect the object to have multiple vpointers for each 'base', and do dispatch through the appropriate one. Given that rust is still a somewhat young language, I could appreciate why the developers might not want to introduce that complexity immediately (being stuck with a poor design forever would be a high cost for little reward), but I wanted to work out exactly how such a system might work (or not work).&lt;/p&gt;

&lt;h5 id="vtablesinrust"&gt;Vtables in Rust&lt;/h5&gt;

&lt;p&gt;Like C++, dynamic dispatch is achieved in Rust  though a table of function pointers (described &lt;a href="https://doc.rust-lang.org/book/trait-objects.html#representation"&gt;here&lt;/a&gt; in the rust docs). According to that documentation, the memory layout of a &lt;code&gt;Mammal&lt;/code&gt; trait object made from a &lt;code&gt;Cat&lt;/code&gt; will consist of two pointers arranged like:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/03/cat_layout-2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;I was surprised to see that the data members of the object had an additional layer of indirection. This is unlike the (typical) C++ representation which would look this:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/03/cat_layout_cpp.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;With the vtable pointer first and the data members immediately following. The rust approach is interesting. It incurs a cost when 'constructing' a trait object, unlike the C++ approach in which a cast to a base pointer is free (or just some addition for multiple inheritance). But this cost is very minor. The rust approach has the benefit that an object does not have to store the vtable pointer if it is never used in a polymorphic context. I think it is fair to say that rust encourages the use of monomorphism, so this is probably a good trade-off.&lt;/p&gt;

&lt;h5 id="traitobjectswithmultiplebounds"&gt;Trait Objects with Multiple Bounds&lt;/h5&gt;

&lt;p&gt;Returning to the original problem, lets consider how it is resolved in C++. If we have multiple traits (purely abstract classes) that we implement for some structure, then an instance of that structure will have the following layout (e.x., Mammal and Clone):&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/03/cat_and_clone_cpp-1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Notice that we now have multiple vtable pointers, one for each base class &lt;code&gt;Cat&lt;/code&gt; inherits from (that contains virtual functions). To convert a &lt;code&gt;Cat*&lt;/code&gt; to a &lt;code&gt;Mammal*&lt;/code&gt;, we don't need to do anything, but to convert a &lt;code&gt;Cat*&lt;/code&gt; to a &lt;code&gt;Clone*&lt;/code&gt;, the compiler will add 8 bytes (assuming &lt;code&gt;sizeof(void*) == 8&lt;/code&gt;) to the &lt;code&gt;this&lt;/code&gt; pointer.&lt;/p&gt;

&lt;p&gt;It is easy to imagine a similar thing for rust:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/03/cat_clone_rust_candidate_1-1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;So there are now two vtable pointers in the trait object. If the compiler needs to perform dynamic dispatch on a &lt;code&gt;Mammal + Clone&lt;/code&gt; trait object, it can access the appropriate entry in the appropriate vtable and perform the call. Because rust does not (yet) support struct inheritance, the problem of determining the correct subobject to pass as &lt;code&gt;self&lt;/code&gt;, does not exist. &lt;code&gt;self&lt;/code&gt; will always be whatever is pointed at by the &lt;code&gt;data&lt;/code&gt; pointer.&lt;/p&gt;

&lt;p&gt;This seems like it would work well, but this approach also has some redundancy. We have multiple copies of the type's size, alignment, and &lt;code&gt;drop&lt;/code&gt; pointer. We can eliminate this redundancy by combining the vtables. This is essentially what happens when you perform trait inheritance like:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/b86e7753e26b57776bb00ef46aac6784.js"&gt;&lt;/script&gt;

&lt;p&gt;Using trait inheritance in this way is a commonly suggested trick to get around the normal limitation of trait objects. The use of trait inheritance produces a single vtable without any redundancy. So the memory layout looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/03/clone_mammal_rust-1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Much simpler! And you can currently do this! Perhaps what we really want is for the compiler to generate a trait like this for us when we try to make a trait object with multiple bounds. But hold on, there are some significant limitations. Namely, you cannot convert a trait object of &lt;code&gt;CloneMammal&lt;/code&gt; in to a trait object of &lt;code&gt;Clone&lt;/code&gt;. This seems like very strange behavior, but it is not hard to see why such a conversion won't work.&lt;/p&gt;

&lt;p&gt;Suppose you attempt to write something like:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/a1acc010590aac091a4d0c968f6024a2.js"&gt;&lt;/script&gt;

&lt;p&gt;Line 10 must fail to compile because the compiler cannot possibly find the appropriate vtable to put in the trait object. It only knows that the object being referenced implements &lt;code&gt;CloneMammal&lt;/code&gt;, but it doesn't know which one. Of course, we can tell that it must be a &lt;code&gt;Cat&lt;/code&gt;, but what if the code was something like:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/fc532dbdae257a03c070d02f7e2b9be1.js"&gt;&lt;/script&gt;

&lt;p&gt;The problem is more clear here. How can the compiler know what vtable to put in the trait object being constructed on line 17? If &lt;code&gt;clone_mammal&lt;/code&gt; refers to a &lt;code&gt;Cat&lt;/code&gt;, then it should be the &lt;code&gt;Cat&lt;/code&gt; vtable for &lt;code&gt;Clone&lt;/code&gt;. If it refers to a &lt;code&gt;Dog&lt;/code&gt; then it should be the &lt;code&gt;Dog&lt;/code&gt; vtable for &lt;code&gt;Clone&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So the trait-inheritance approach has this limitation. You cannot convert a trait object in to any other kind of trait object, even when the trait object you want is &lt;em&gt;more specific&lt;/em&gt; than the one you already have.&lt;/p&gt;

&lt;p&gt;The multiple vtable pointer approach seems like a good way forward to allowing trait objects with multiple bounds. It is trivial to convert to a less-bounded trait object with that setup. The vtable the compiler should use is simply whatever is already &lt;code&gt;Clone&lt;/code&gt; vtable pointer slot (the second pointer in diagram 4).&lt;/p&gt;

&lt;h5 id="conclusions"&gt;Conclusions&lt;/h5&gt;

&lt;p&gt;I hope going through this was a useful exercise to some readers. It certainly helped me organize how I was thinking about trait objects. In practice, I think this is not really a pressing issue, the restriction was just surprising to me.&lt;/p&gt;</content:encoded></item><item><title>Reversing C++ Virtual Functions: Part 2</title><description>&lt;p&gt;In the &lt;a href="https://alschwalm.com/blog/static/2016/12/17/reversing-c-virtual-functions/"&gt;previous part&lt;/a&gt; I described one approach to 'devirtualize' function calls in a small C++ program. Naturally there were several limitations to that approach, namely that it is very manual. If the target binary contains thousands of vtables, it is not practical to manually locate the tables and create&lt;/p&gt;</description><link>https://alschwalm.com/blog/static/2017/01/24/reversing-c-virtual-functions-part-2-2/</link><guid isPermaLink="false">a88a9c7f-9cef-4f3a-a413-1ab89378d0be</guid><dc:creator>Adam Schwalm</dc:creator><pubDate>Tue, 24 Jan 2017 03:13:19 GMT</pubDate><content:encoded>&lt;p&gt;In the &lt;a href="https://alschwalm.com/blog/static/2016/12/17/reversing-c-virtual-functions/"&gt;previous part&lt;/a&gt; I described one approach to 'devirtualize' function calls in a small C++ program. Naturally there were several limitations to that approach, namely that it is very manual. If the target binary contains thousands of vtables, it is not practical to manually locate the tables and create these structures and relationships.&lt;/p&gt;

&lt;p&gt;So, in this part I will go through a more precise description of the layout of vtables and how we can find them programmatically. I will also show how we can sometimes recover relationships between these vtables (and therefore, between the types they are associated with).&lt;/p&gt;

&lt;p&gt;But first I need to describe the set of binaries this is applicable to. In the first part I mentioned that most things related to vtable layout were not specified in the standard, and so tended to vary from compiler to compiler. This is because the C++ standard needs to be applicable regardless of the underlying architecture. It would be unfortunate if the spec required some specific vtable layout that was inefficient on some architecture. The compiler developers for that architecture would be required to choose between performance and compliance (more than they already are).&lt;/p&gt;

&lt;p&gt;However, because programs produced by different compilers frequently need to interact (most notable, for dynamic linking), compiler developers agreed to a kind of supplemental specification for things like vtable layout, exception implementation and others. The most common of these is the &lt;a href="https://mentorembedded.github.io/cxx-abi/abi.html"&gt;Itanium C++ ABI&lt;/a&gt;. This standard is implemented by GCC, clang, ICC, and many other compilers (but notably, not Visual Studio). The descriptions I give will be applicable these compilers.&lt;/p&gt;

&lt;p&gt;The Itanium ABI is also still ambiguous in some areas. For example, it does not state what segments should be used to store vtables. So I will further specify that I'm describing GCC's particular brand of Itanium. So in essence, I am describing the highlighted section:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/01/GCC_location-1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Additionally, the following assumptions are made:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;RTTI is disabled (if it were on, this would be much easier)  &lt;/li&gt;
&lt;li&gt;The program does not contain occurrences of virtual inheritance. &lt;em&gt;Unfortunately, discussing this would dramatically increase the complexity of this topic, and because virtual inheritance is somewhat uncommon I didn't think it was worth it.&lt;/em&gt;  &lt;/li&gt;
&lt;li&gt;These are 32bit binaries&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="moreaboutvtablelayout"&gt;More about vtable layout&lt;/h5&gt;

&lt;p&gt;Before we move forward, recall that in part 1, we described a vtable as a contiguous collection of function pointers in a data segment of the binary. We can also say that the array should only be referenced by its first element, because the other elements will be accessed as offsets in to this array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.rodata:08048D48 off_8048D48     dd offset sub_8048B6E
.rodata:08048D4C                 dd offset sub_8048BC2
.rodata:08048D50                 dd offset sub_8048BE0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a section from a binary that seems to fit that definition. It is an array of 3 function pointers in the '.rodata' segment, and only the pointer at &lt;code&gt;0x08048D48&lt;/code&gt; is referenced. It turns out that this &lt;em&gt;is&lt;/em&gt; a vtable, so maybe this heuristic is good enough? If we were to compile the following code:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/5a8cd4928eb8e3c1d2993a7acc0099d1.js"&gt;&lt;/script&gt;

&lt;p&gt;We would expect there to be 5 vtables, one for &lt;code&gt;Mammal&lt;/code&gt;, &lt;code&gt;Cat&lt;/code&gt;, &lt;code&gt;Dog&lt;/code&gt;, &lt;code&gt;Bird&lt;/code&gt;, and &lt;code&gt;Bat&lt;/code&gt;. But as you might have guessed, things aren't that simple. In fact there are 6 regions in the binary that meet the above criteria. It becomes clear why this happens when you consider the layout of an object with multiple inheritance.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/01/Bat-Layout--1-.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Notice that &lt;code&gt;Bat&lt;/code&gt; includes a complete instance (called subobjects) of &lt;code&gt;Bird&lt;/code&gt; and &lt;code&gt;Mammal&lt;/code&gt; as well as a &lt;code&gt;vptr&lt;/code&gt; for each. These pointers point to different tables. So a type with multiple parents has a vtable in the binary for each one. The Itanium ABI refers to these as a "virtual table group".&lt;/p&gt;

&lt;h5 id="virtualtablegroups"&gt;Virtual Table Groups&lt;/h5&gt;

&lt;p&gt;A virtual table group consists of a &lt;em&gt;primary table&lt;/em&gt; for the first parent type, and an arbitrary number of &lt;em&gt;secondary tables&lt;/em&gt;, one for each parent type after the first. These tables will be adjacent in the binary, in the order the parent types were declared in the source. With this in mind, we would expect the vtable group for &lt;code&gt;Bat&lt;/code&gt; to be something like:&lt;/p&gt;

&lt;table&gt;  
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Offset&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
      &lt;th&gt;Bat's vtable for&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tr&gt;
    &lt;td&gt;0&lt;/td&gt;
    &lt;td&gt;Address of Destructor 1&lt;/td&gt;
    &lt;td&gt;Bird&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;4&lt;/td&gt;
    &lt;td&gt;Address of Destructor 2&lt;/td&gt;
    &lt;td&gt;Bird&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;8&lt;/td&gt;
    &lt;td&gt;Address of Bat::Fly&lt;/td&gt;
    &lt;td&gt;Bird&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;12&lt;/td&gt;
    &lt;td&gt;Address of Destructor 1&lt;/td&gt;
    &lt;td&gt;Mammal&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;16&lt;/td&gt;
    &lt;td&gt;Address of Destructor 2&lt;/td&gt;
    &lt;td&gt;Mammal&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;20&lt;/td&gt;
    &lt;td&gt;Address of Mammal::walk&lt;/td&gt;
    &lt;td&gt;Mammal&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;With each vtable taking 12 bytes. Recall from part 1 that there will be two destructors, and because &lt;code&gt;Bat&lt;/code&gt; does not override &lt;code&gt;walk&lt;/code&gt;, we would expect the &lt;code&gt;walk&lt;/code&gt; from &lt;code&gt;Mammal&lt;/code&gt; to appear in &lt;code&gt;Bat&lt;/code&gt;'s table. However, if we examine the binary we don't see any place with 6 consecutive function pointers in the &lt;code&gt;.rodata&lt;/code&gt; segment.&lt;/p&gt;

&lt;p&gt;If we look more closely at the Itanium specification, we can see why. A virtual table does not consist of just function pointers. In fact a vtable looks more like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/01/full_vtable--2-.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;figcaption&gt;Itanium vtable layout (without virtual inheritance)&lt;/figcaption&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;RTTI pointer&lt;/code&gt; will typically point to an RTTI struct (that is also described by the Itanium spec). However, because we are assuming RTTI is disabled, it will always be 0. The offset to top has a value equal to the number of bytes that must be added to the &lt;code&gt;this&lt;/code&gt; pointer to get the start of the object from some subobject. This is probably a little confusing, so to clarify, image the following code:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/4d31be0344b8d1ff61ebbea1a94b0f3b.js"&gt;&lt;/script&gt;

&lt;p&gt;These assignments to &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; are both valid. The first does not require any instructions. A &lt;code&gt;Bat&lt;/code&gt; is a &lt;code&gt;Bird&lt;/code&gt;, and because &lt;code&gt;Bird&lt;/code&gt; is its first parent, the &lt;code&gt;Bird&lt;/code&gt; subobject is at the very beginning of any &lt;code&gt;Bat&lt;/code&gt; object. Thus, a pointer to a &lt;code&gt;Bat&lt;/code&gt; is also a pointer to a &lt;code&gt;Bird&lt;/code&gt;. This is just like normal, single inheritance.&lt;/p&gt;

&lt;p&gt;However, the assignment to &lt;code&gt;m&lt;/code&gt; does require work. The &lt;code&gt;Mammal&lt;/code&gt; subobject inside a &lt;code&gt;Bat&lt;/code&gt; is not at the beginning, so the compiler must insert some instructions to add to &lt;code&gt;bat&lt;/code&gt; to make it point to its &lt;code&gt;Mammal&lt;/code&gt; subobject. The value added will be the size of &lt;code&gt;Bird&lt;/code&gt; (and alignment). The negative of this value will be stored in the Offset to Top field.&lt;/p&gt;

&lt;p&gt;This Offset to Top component of the vtable allows us to easily identify vtable groups. &lt;em&gt;A group will consist of those consecutive vtables that have decreasing values in the Offset to Top&lt;/em&gt;. Consider the following:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/01/2017-01-23-182702_576x703_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;These are the 6 vtables found in the binary built from the above source. Notice that table 2 has a value of -4 (0xFFFFFFFC as a signed int) for its Offset to Top, and all other tables have a value of 0. Also, each RTTI pointer is 0, as we expected. The -4 tells us two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Table 2 is a secondary table in a vtable group (because offset to top is not 0)  &lt;/li&gt;
&lt;li&gt;The size of the type associated with table 1 is 4. Keep in mind that because tables 1 and 2 form a table group, the size of the type associated with &lt;em&gt;just&lt;/em&gt; table 1 is actually the size of &lt;em&gt;part&lt;/em&gt; of the object (i.e a subobject).&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="findingvtablesprogrammatically"&gt;Finding Vtables Programmatically&lt;/h5&gt;

&lt;p&gt;From the above, we can devise the following simple procedures to find vtable (groups) from a binary:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/2c8a16576d713bacdbc3f9df36c0e843.js"&gt;&lt;/script&gt;

&lt;p&gt;After running the above in the IDA python interpreter, you can execute &lt;code&gt;find_tablegroups()&lt;/code&gt; to get a list of vtable group addresses. This could be combined with additional code to construct structures from each vtable, for example.&lt;/p&gt;

&lt;p&gt;However, just knowing where tablegroups are is not very useful. We need some information about the relationships between the types associated with the tables. Then, we will be able to generate a list of 'candidate' function calls for a virtual call-site, so long as we know the 'family' the type is associated with.&lt;/p&gt;

&lt;h5 id="recoveringtyperelationships"&gt;Recovering Type Relationships&lt;/h5&gt;

&lt;p&gt;The simplest approach to recovering these relationships is to recognize that two vtables sharing a function pointer are necessarily related. We cannot recover the nature of that relationship, but it is enough to determine that they are in the same family.&lt;/p&gt;

&lt;p&gt;But we can go further by considering the behavior of constructors and destructors in C++. An constructor performs the following steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Invoke the parent class's constructors  &lt;/li&gt;
&lt;li&gt;Initialize the &lt;code&gt;vptr&lt;/code&gt;(s) to point to this type's vtable(s)  &lt;/li&gt;
&lt;li&gt;Initialize the members of the object  &lt;/li&gt;
&lt;li&gt;Run whatever other code is in the constructor&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The destructor performs essentially the opposite steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Set the &lt;code&gt;vptr&lt;/code&gt;(s) to point to this type's vtable(s)  &lt;/li&gt;
&lt;li&gt;Run whatever other code is in the destructor  &lt;/li&gt;
&lt;li&gt;Destroy the members of the object  &lt;/li&gt;
&lt;li&gt;Invoke the parent class's destructor&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notice that the &lt;code&gt;vptr&lt;/code&gt; is again set to point to the vtable. This seems odd until you consider that virtual function calls should still work during destruction. &lt;/p&gt;

&lt;p&gt;Suppose we modified the &lt;code&gt;Bird&lt;/code&gt; destructor so it called &lt;code&gt;fly&lt;/code&gt;. If you were to destruct a &lt;code&gt;Bat&lt;/code&gt; object (which in turn called the &lt;code&gt;Bird&lt;/code&gt; destructor when the &lt;code&gt;Bat&lt;/code&gt; one was finished), it should call &lt;code&gt;Bird::fly&lt;/code&gt; not &lt;code&gt;Bat::fly&lt;/code&gt;, because the object is no longer a &lt;code&gt;Bat&lt;/code&gt;. For this to work, the &lt;code&gt;Bird&lt;/code&gt; destructor must update the &lt;code&gt;vptr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, we know that each destructor will call the parent type's destructor, and we know that these destructors will reference the vtable (to assign it to the vptr). We can therefore reconstruct the inheritance hierarchy for a type by "following the destructors". Similar logic can be used for Constructors as well. &lt;/p&gt;

&lt;p&gt;Consider the first entry in the first vtable (which we would expect to be a destructor):&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/01/2017-01-23-184412_418x135_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Notice that there are two assignments, and these are both address points of vtables. This is step 1 in the list above. These object does not seem to have any members, because it proceeds directly to step 4 and calls the two other destructors. We can confirm that these other functions are destructors because of their location in a vtable (at the start of table 6 and table 3). Doing this for the remaining tables this tells us that the inheritance hierarchy was laid out like:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/01/inheritance--1-.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;This matches the actual hierarchy from the source. There are two base classes and one class that has two parents.&lt;/p&gt;

&lt;h5 id="identifyingconstructors"&gt;Identifying Constructors&lt;/h5&gt;

&lt;p&gt;By similar reasoning, we can find the constructors associated with a vtable by noting that the constructors will be &lt;em&gt;those functions that assign their vptr to a vtable address that are not destructors&lt;/em&gt;. By applying this rule to the target, we discover that there are 5 such functions, one for each type:&lt;/p&gt;

&lt;table&gt;  
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Constructor&lt;/th&gt;
      &lt;th&gt;Table&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tr&gt;
    &lt;td&gt;sub_8048AEC&lt;/td&gt;
    &lt;td&gt;Table 1/2&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;sub_8048A64&lt;/td&gt;
    &lt;td&gt;Table 3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;sub_80489A8&lt;/td&gt;
    &lt;td&gt;Table 4&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;sub_80488EC&lt;/td&gt;
    &lt;td&gt;Table 5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;sub_8048864&lt;/td&gt;
    &lt;td&gt;Table 6&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h5 id="devirtualize"&gt;Devirtualize&lt;/h5&gt;

&lt;p&gt;With this, we can look at the decompiled body of &lt;code&gt;main&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/01/2017-01-23-185429_638x534_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;The virtual functions are clearly visible on lines 28 and 29. However, we can also identify constructors on lines 13, 16, 22, and 25 from the tables above. Using this knowledge, we can follow the process from part 1 to see the devirtualization:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2017/01/2017-01-23-195432_518x533_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;In the above screenshot, I have set &lt;code&gt;v0&lt;/code&gt; to have type &lt;code&gt;type_8048D40*&lt;/code&gt;. This is the type associated with table 1/2 and also with the constructor on line 13. Similarly, the constructor on line 16 is associated with table 5, which I have created a type for named &lt;code&gt;type_8048D98&lt;/code&gt; (the are the addresses at which the tables start. I could just as easily have called them &lt;code&gt;table_5&lt;/code&gt; or some such). The same thing could be done with &lt;code&gt;v2&lt;/code&gt; and &lt;code&gt;v3&lt;/code&gt; to see the alternate possibilities for lines 28 and 29.&lt;/p&gt;

&lt;p&gt;So, while the original source contained strings that would make identifying types and methods easy, we did not need any of them to perform our "devirtualization".&lt;/p&gt;

&lt;h5 id="conclusions"&gt;Conclusions&lt;/h5&gt;

&lt;p&gt;This is still a very manual process, but we have come a bit further. We are now able to (approximately) automatically detect vtables. It is not hard to see how we will be able to automate the construction of the associated structures, and then perhaps the location of constructor calls. We could also imagine reconstructing type trees. In the next part, we will delve in to this a bit more. &lt;/p&gt;</content:encoded></item><item><title>Reversing C++ Virtual Functions: Part 1</title><description>&lt;p&gt;There are a few posts in various parts of the internet discussing reverse engineering C++, and these often address virtual functions to a large or small extent. However, I wanted to take some time to write about dealing with virtual functions in large, ‘enterprisy’ code-bases. These can often include thousands&lt;/p&gt;</description><link>https://alschwalm.com/blog/static/2016/12/17/reversing-c-virtual-functions/</link><guid isPermaLink="false">1774e608-8aad-4eab-964b-9ea6f22929d6</guid><dc:creator>Adam Schwalm</dc:creator><pubDate>Sat, 17 Dec 2016 22:04:31 GMT</pubDate><content:encoded>&lt;p&gt;There are a few posts in various parts of the internet discussing reverse engineering C++, and these often address virtual functions to a large or small extent. However, I wanted to take some time to write about dealing with virtual functions in large, ‘enterprisy’ code-bases. These can often include thousands of classes and massive type hierarchies, so I think it is worth describing some techniques for reversing them. But before that I’m going to go through some more simple cases. If you are already familiar with virtual function reversing, then you my want to proceed directly to &lt;a href="https://alschwalm.com/blog/static/2017/01/24/reversing-c-virtual-functions-part-2-2/"&gt;part 2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It’s also worth noting the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The code was compiled without RTTI (RTTI will be discussed later) and without exceptions&lt;/li&gt;
&lt;li&gt;I’m using 32bit x86 as the example platform&lt;/li&gt;
&lt;li&gt;The binaries have been stripped&lt;/li&gt;
&lt;li&gt;Most virtual function implementation details are not standardized and can vary from compiler to compiler. For this reason, we’re going to focus on the behavior of GCC.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So in general, the binaries we’re looking at have been compiled with &lt;code&gt;g++ -m32 -fno-rtti -fnoexceptions -O1 file.cpp&lt;/code&gt; and then stripped with &lt;code&gt;strip&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id="thegoal"&gt;The Goal&lt;/h5&gt;

&lt;p&gt;In most cases, we cannot hope to “devirtualize” a virtual function call. The information needed to do that is just not present until runtime. Instead, the goal of this exercise will be to determine which function might be being called at a particular point. In later parts we will focus on narrowing down the possibilities.&lt;/p&gt;

&lt;h5 id="thebasics"&gt;The Basics&lt;/h5&gt;

&lt;p&gt;I’m assuming that you are familiar with writing C++ but maybe not with its implementation. So, let’s start by looking at how the compiler implements virtual functions. Suppose we have the following classes:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/648158e4ed019cdd40632fc9335b4994.js"&gt;&lt;/script&gt;

&lt;p&gt;And we have some code that uses them:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/d978a2deb7cd47d467323762eede8f98.js"&gt;&lt;/script&gt;

&lt;p&gt;Of course whether &lt;code&gt;m&lt;/code&gt; is a &lt;em&gt;Cat&lt;/em&gt; or &lt;em&gt;Dog&lt;/em&gt; depends on the output of &lt;code&gt;rand&lt;/code&gt;. The compiler cannot know this ahead of time, so how does it call the right function? The answer is that for each type having a virtual function, the compiler inserts a table of function pointers called a &lt;em&gt;vtable&lt;/em&gt; into the resulting binary. Each instance of such a type is given an additional member called a &lt;em&gt;vptr&lt;/em&gt; that points to the correct &lt;em&gt;vtable&lt;/em&gt; for that object. Code to initialize this pointer with the right value will be added to the constructor.&lt;/p&gt;

&lt;p&gt;Then, when the compiler needs to call a virtual function, it can just access the correct entry in the &lt;em&gt;vtable&lt;/em&gt; for the object and call that. This means that the entries in the table must be in the same order for each related type (each class’s &lt;code&gt;run&lt;/code&gt; could be at index 1, every &lt;code&gt;walk&lt;/code&gt; at index 2, etc).&lt;/p&gt;

&lt;p&gt;So we would expect to find three tables in the binary for &lt;em&gt;Mammal&lt;/em&gt;, &lt;em&gt;Cat&lt;/em&gt; and &lt;em&gt;Dog&lt;/em&gt;. We can locate them quickly by looking through &lt;code&gt;.rodata&lt;/code&gt; for adjacent function offsets:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-14-194724_796x759_scrot.png" alt="IDA is not always great at detecting function addresses in rodata. You may need to play around a little to see the first table."&gt;&lt;/p&gt;

&lt;p&gt;What about the main function? It decompiles to:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-14-175006_728x438_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;We can see that 4 bytes are being allocated in either branch. This makes sense, as the only data in the structure is the &lt;em&gt;vptr&lt;/em&gt; added by the compiler. We can also see the virtual function calls on lines 15 and 17. In the first, the compiler is dereferencing (to get the &lt;em&gt;vptr&lt;/em&gt;) and adding 12 to access the 4th entry in the &lt;em&gt;vtable&lt;/em&gt;. Line 17 gets the 2nd entry in the table. The program then calls the function pointer it retrieved from the table.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-14-214141_825x115_scrot.png" alt=""&gt;
&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-14-214210_828x118_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Looking back at the tables, the 4th entries are &lt;code&gt;sub_80487AA&lt;/code&gt;, &lt;code&gt;sub_804877E&lt;/code&gt;, and &lt;code&gt;___cxa_pure_virtual&lt;/code&gt;. If we look at the bodies of the two “sub_” functions we see that they are the definitions of &lt;code&gt;walk&lt;/code&gt; for &lt;em&gt;Dog&lt;/em&gt; and &lt;em&gt;Cat&lt;/em&gt; (shown in the pictures). By elimination, the &lt;code&gt;___cxa_pure_virtual&lt;/code&gt; function must belong to the vtable for &lt;em&gt;Mammal&lt;/em&gt;. This makes sense, as &lt;em&gt;Mammal&lt;/em&gt; has no definition of &lt;code&gt;walk&lt;/code&gt;, and these “pure_virtual” entries are inserted by GCC when a function is (unsurprisingly) purely virtual. So, table 1 must be for &lt;em&gt;Mammal&lt;/em&gt; objects, 2 is for &lt;em&gt;Cats&lt;/em&gt; and table 3 is for &lt;em&gt;Dogs&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;But it is seems strange that there are 5 entries in each vtable when there are only 4 virtual functions in play:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;walk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the destructors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The additional entry is an ‘extra’ destructor. This is here because GCC will insert multiple destructors that are used in different circumstances. The first of these will simply destroy the members of the object. The second will also delete the memory that was allocated for the object (this is the version called in the example in line 17). In some cases there may be a 3rd version that is used in certain virtual-inheritance circumstances.&lt;/p&gt;

&lt;p&gt;By looking back at the contents of the ‘sub_’ functions, we find the layout of the vtables are as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| Offset | Pointer to  |
|--------+-------------|
|      0 | Destructor1 |
|      4 | Destructor2 |
|      8 | run         |
|     12 | walk        |
|     16 | move        |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, notice that the first two entries in the &lt;em&gt;Mammal&lt;/em&gt; table are zero. This is an eccentricity of newer versions of GCC. The compiler will replace the destructor entries with NULL pointers in classes that have a pure-virtual method (i.e., classes that are abstract).&lt;/p&gt;

&lt;p&gt;With all this in mind, let’s do some renaming. Afterwards we’re left with:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-15-192953_796x691_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Notice that because neither &lt;em&gt;Cat&lt;/em&gt; nor &lt;em&gt;Dog&lt;/em&gt; implemented &lt;code&gt;move&lt;/code&gt;, they both inherited the definition from &lt;em&gt;Mammal&lt;/em&gt; and so the move entries in their vtables are the same.&lt;/p&gt;

&lt;h5 id="structures"&gt;Structures&lt;/h5&gt;

&lt;p&gt;At this point is useful to start defining some structures. We’ve already seen that the only member of the &lt;em&gt;Mammal&lt;/em&gt;, &lt;em&gt;Cat&lt;/em&gt;, and &lt;em&gt;Dog&lt;/em&gt; structures will be their vptrs. So we can define these quickly:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-16-164359_616x303_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;The next step is a bit more complicated. We’re going to create a structure for each &lt;em&gt;vtable&lt;/em&gt;. The objective here is to get the decompiler output to show us what function would actually be called if &lt;code&gt;m&lt;/code&gt; had a particular type. We can then cycle through these possibilities and examine all of the options.&lt;/p&gt;

&lt;p&gt;To achieve this, the members of this structure will have the name of the corresponding function it will point to, like so:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-16-164830_600x788_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;You will need to set the type of the &lt;em&gt;vptr&lt;/em&gt; for each structure to be the corresponding &lt;code&gt;Vtable&lt;/code&gt; type. For example, the type of the &lt;em&gt;vptr&lt;/em&gt; for &lt;code&gt;Cat&lt;/code&gt; should be &lt;code&gt;CatVtable*&lt;/code&gt;. Additionally, I have set the type of each vtable entry to be a function pointer. This will help IDA show things correctly. So the type of the &lt;code&gt;Dog__run&lt;/code&gt; element should be &lt;code&gt;void (*) (Dog*)&lt;/code&gt; (because that is the signature of &lt;code&gt;Dog__run&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;If we go back to the decompiled code for main, we can now rename the local variable to &lt;code&gt;m&lt;/code&gt;, and set its type to be &lt;code&gt;Cat*&lt;/code&gt; or &lt;code&gt;Dog*&lt;/code&gt;. Afterwards we see:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-16-185921_437x338_scrot2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Now we can easily see the possible functions being called at the call-sites. If &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;Cat&lt;/code&gt; then line 15 will call &lt;code&gt;Cat__walk&lt;/code&gt;, if it is a &lt;code&gt;Dog&lt;/code&gt; then it will call &lt;code&gt;Dog__walk&lt;/code&gt;. Obviously this was a simple example, but this is the general idea.&lt;/p&gt;

&lt;p&gt;We could also set the type of &lt;code&gt;m&lt;/code&gt; to be &lt;code&gt;Mammal*&lt;/code&gt;, but we will see some problems if we do that:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-16-190425_594x341_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Notice that if the real type of &lt;code&gt;m&lt;/code&gt; was &lt;code&gt;Mammal&lt;/code&gt; then the call at line 15 would be to a pure-virtual function. This should never happen. There's also a call to a null pointer at line 17 which would obviously cause issues. So we can conclude that &lt;code&gt;m&lt;/code&gt; must not be a &lt;code&gt;Mammal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This may seem strange, because &lt;code&gt;m&lt;/code&gt; is in fact declared as a &lt;code&gt;Mammal*&lt;/code&gt;. However, that type is the compile-time type (a.k.a., the &lt;em&gt;static type&lt;/em&gt;). We are interested in the &lt;em&gt;dynamic&lt;/em&gt; type (or runtime-type) of &lt;code&gt;m&lt;/code&gt;, because this is what determines which function is called in a virtual function call. In fact, the dynamic type of an object can &lt;em&gt;never&lt;/em&gt; be an abstract type. So if a given &lt;em&gt;vtable&lt;/em&gt; contains one of the &lt;code&gt;___cxa_pure_virtual&lt;/code&gt; functions, then it is not a candidate and you can ignore it. We could have not created a &lt;em&gt;vtable&lt;/em&gt; structure for &lt;em&gt;Mammal&lt;/em&gt; because it will never be used (but I hope seeing why was useful).&lt;/p&gt;

&lt;p&gt;So the dynamic type will be &lt;em&gt;Cat&lt;/em&gt; or &lt;em&gt;Dog&lt;/em&gt;, and we know which functions will be called in either case by looking at their vtable entries. This is the basics of virtual function reverse engineering. In the next part we will go in to how to deal with larger code bases and more complex scenarios.&lt;/p&gt;</content:encoded></item></channel></rss>