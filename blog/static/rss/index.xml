<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Security Through Obscurity</title><description>On reverse engineering, programming, and maybe some other stuff.</description><link>https://alschwalm.com/blog/static/</link><generator>Ghost 0.11</generator><lastBuildDate>Sun, 18 Dec 2016 21:36:38 GMT</lastBuildDate><atom:link href="https://alschwalm.com/blog/static/rss/index.xml" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Reversing C++ Virtual Functions: Part 1</title><description>&lt;p&gt;There are a few posts in various parts of the internet discussing reverse engineering C++, and these often address virtual functions to a large or small extent. However, I wanted to take some time to write about dealing with virtual functions in large, ‘enterprisy’ code-bases. These can often include thousands&lt;/p&gt;</description><link>https://alschwalm.com/blog/static/2016/12/17/reversing-c-virtual-functions/</link><guid isPermaLink="false">1774e608-8aad-4eab-964b-9ea6f22929d6</guid><dc:creator>Adam Schwalm</dc:creator><pubDate>Sat, 17 Dec 2016 22:04:31 GMT</pubDate><content:encoded>&lt;p&gt;There are a few posts in various parts of the internet discussing reverse engineering C++, and these often address virtual functions to a large or small extent. However, I wanted to take some time to write about dealing with virtual functions in large, ‘enterprisy’ code-bases. These can often include thousands of classes and massive type hierarchies, so I think it is worth describing some techniques for reversing them. But before that I’m going to go through some more simple cases. If you are already familiar with virtual function reversing, then you my want to proceed directly to part 2.&lt;/p&gt;

&lt;p&gt;It’s also worth noting the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The code was compiled without RTTI (RTTI will be discussed later) and without exceptions&lt;/li&gt;
&lt;li&gt;I’m using 32bit x86 as the example platform&lt;/li&gt;
&lt;li&gt;The binaries have been stripped&lt;/li&gt;
&lt;li&gt;Most virtual function implementation details are not standardized and can vary from compiler to compiler. For this reason, we’re going to focus on the behavior of GCC.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So in general, the binaries we’re looking at have been compiled with &lt;code&gt;g++ -m32 -fno-rtti -fnoexceptions -O1 file.cpp&lt;/code&gt; and then stripped with &lt;code&gt;strip&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id="thegoal"&gt;The Goal&lt;/h5&gt;

&lt;p&gt;In most cases, we cannot hope to “devirtualize” a virtual function call. The information needed to do that is just not present until runtime. Instead, the goal of this exercise will be to determine which function might be being called at a particular point. In later parts we will focus on narrowing down the possibilities.&lt;/p&gt;

&lt;h5 id="thebasics"&gt;The Basics&lt;/h5&gt;

&lt;p&gt;I’m assuming that you are familiar with writing C++ but maybe not with its implementation. So, let’s start by looking at how the compiler implements virtual functions. Suppose we have the following classes:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/648158e4ed019cdd40632fc9335b4994.js"&gt;&lt;/script&gt;

&lt;p&gt;And we have some code that uses them:&lt;/p&gt;

&lt;script src="https://gist.github.com/ALSchwalm/d978a2deb7cd47d467323762eede8f98.js"&gt;&lt;/script&gt;

&lt;p&gt;Of course whether &lt;code&gt;m&lt;/code&gt; is a &lt;em&gt;Cat&lt;/em&gt; or &lt;em&gt;Dog&lt;/em&gt; depends on the output of &lt;code&gt;rand&lt;/code&gt;. The compiler cannot know this ahead of time, so how does it call the right function? The answer is that for each type having a virtual function, the compiler inserts a table of function pointers called a &lt;em&gt;vtable&lt;/em&gt; into the resulting binary. Each instance of such a type is given an additional member called a &lt;em&gt;vptr&lt;/em&gt; that points to the correct &lt;em&gt;vtable&lt;/em&gt; for that object. Code to initialize this pointer with the right value will be added to the constructor.&lt;/p&gt;

&lt;p&gt;Then, when the compiler needs to call a virtual function, it can just access the correct entry in the &lt;em&gt;vtable&lt;/em&gt; for the object and call that. This means that the entries in the table must be in the same order for each related type (each class’s &lt;code&gt;run&lt;/code&gt; could be at index 1, every &lt;code&gt;walk&lt;/code&gt; at index 2, etc).&lt;/p&gt;

&lt;p&gt;So we would expect to find three tables in the binary for &lt;em&gt;Mammal&lt;/em&gt;, &lt;em&gt;Cat&lt;/em&gt; and &lt;em&gt;Dog&lt;/em&gt;. We can locate them quickly by looking through &lt;code&gt;.rodata&lt;/code&gt; for adjacent function offsets:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-14-194724_796x759_scrot.png" alt="IDA is not always great at detecting function addresses in rodata. You may need to play around a little to see the first table."&gt;&lt;/p&gt;

&lt;p&gt;What about the main function? It decompiles to:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-14-175006_728x438_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;We can see that 4 bytes are being allocated in either branch. This makes sense, as the only data in the structure is the &lt;em&gt;vptr&lt;/em&gt; added by the compiler. We can also see the virtual function calls on lines 15 and 17. In the first, the compiler is dereferencing (to get the &lt;em&gt;vptr&lt;/em&gt;) and adding 12 to access the 4th entry in the &lt;em&gt;vtable&lt;/em&gt;. Line 17 gets the 2nd entry in the table. The program then calls the function pointer it retrieved from the table.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-14-214141_825x115_scrot.png" alt=""&gt;
&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-14-214210_828x118_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Looking back at the tables, the 4th entries are &lt;code&gt;sub_80487AA&lt;/code&gt;, &lt;code&gt;sub_804877E&lt;/code&gt;, and &lt;code&gt;___cxa_pure_virtual&lt;/code&gt;. If we look at the bodies of the two “sub_” functions we see that they are the definitions of &lt;code&gt;walk&lt;/code&gt; for &lt;em&gt;Dog&lt;/em&gt; and &lt;em&gt;Cat&lt;/em&gt; (shown in the pictures). By elimination, the &lt;code&gt;___cxa_pure_virtual&lt;/code&gt; function must belong to the vtable for &lt;em&gt;Mammal&lt;/em&gt;. This makes sense, as &lt;em&gt;Mammal&lt;/em&gt; has no definition of &lt;code&gt;walk&lt;/code&gt;, and these “pure_virtual” entries are inserted by GCC when a function is (unsurprisingly) purely virtual. So, table 1 must be for &lt;em&gt;Mammal&lt;/em&gt; objects, 2 is for &lt;em&gt;Cats&lt;/em&gt; and table 3 is for &lt;em&gt;Dogs&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;But it is seems strange that there are 5 entries in each vtable when there are only 4 virtual functions in play:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;walk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the destructors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The additional entry is an ‘extra’ destructor. This is here because GCC will insert multiple destructors that are used in different circumstances. The first of these will simply destroy the members of the object. The second will also delete the memory that was allocated for the object (this is the version called in the example in line 17). In some cases there may be a 3rd version that is used in certain virtual-inheritance circumstances.&lt;/p&gt;

&lt;p&gt;By looking back at the contents of the ‘sub_’ functions, we find the layout of the vtables are as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| Offset | Pointer to  |
|--------+-------------|
|      0 | Destructor1 |
|      4 | Destructor2 |
|      8 | run         |
|     12 | walk        |
|     16 | move        |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, notice that the first two entries in the &lt;em&gt;Mammal&lt;/em&gt; table are zero. This is an eccentricity of newer versions of GCC. The compiler will replace the destructor entries with NULL pointers in classes that have a pure-virtual method (i.e., classes that are abstract).&lt;/p&gt;

&lt;p&gt;With all this in mind, let’s do some renaming. Afterwards we’re left with:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-15-192953_796x691_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Notice that because neither &lt;em&gt;Cat&lt;/em&gt; nor &lt;em&gt;Dog&lt;/em&gt; implemented &lt;code&gt;move&lt;/code&gt;, they both inherited the definition from &lt;em&gt;Mammal&lt;/em&gt; and so the move entries in their vtables are the same.&lt;/p&gt;

&lt;h5 id="structures"&gt;Structures&lt;/h5&gt;

&lt;p&gt;At this point is useful to start defining some structures. We’ve already seen that the only member of the &lt;em&gt;Mammal&lt;/em&gt;, &lt;em&gt;Cat&lt;/em&gt;, and &lt;em&gt;Dog&lt;/em&gt; structures will be their vptrs. So we can define these quickly:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-16-164359_616x303_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;The next step is a bit more complicated. We’re going to create a structure for each &lt;em&gt;vtable&lt;/em&gt;. The objective here is to get the decompiler output to show us what function would actually be called if &lt;code&gt;m&lt;/code&gt; had a particular type. We can then cycle through these possibilities and examine all of the options.&lt;/p&gt;

&lt;p&gt;To achieve this, the members of this structure will have the name of the corresponding function it will point to, like so:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-16-164830_600x788_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;You will need to set the type of the &lt;em&gt;vptr&lt;/em&gt; for each structure to be the corresponding &lt;code&gt;Vtable&lt;/code&gt; type. For example, the type of the &lt;em&gt;vptr&lt;/em&gt; for &lt;code&gt;Cat&lt;/code&gt; should be &lt;code&gt;CatVtable*&lt;/code&gt;. Additionally, I have set the type of each vtable entry to be a function pointer. This will help IDA show things correctly. So the type of the &lt;code&gt;Dog__run&lt;/code&gt; element should be &lt;code&gt;void (*) (Dog*)&lt;/code&gt; (because that is the signature of &lt;code&gt;Dog__run&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;If we go back to the decompiled code for main, we can now rename the local variable to &lt;code&gt;m&lt;/code&gt;, and set its type to be &lt;code&gt;Cat*&lt;/code&gt; or &lt;code&gt;Dog*&lt;/code&gt;. Afterwards we see:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-16-185921_437x338_scrot2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Now we can easily see the possible functions being called at the call-sites. If &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;Cat&lt;/code&gt; then line 15 will call &lt;code&gt;Cat__walk&lt;/code&gt;, if it is a &lt;code&gt;Dog&lt;/code&gt; then it will call &lt;code&gt;Dog__walk&lt;/code&gt;. Obviously this was a simple example, but this is the general idea.&lt;/p&gt;

&lt;p&gt;We could also set the type of &lt;code&gt;m&lt;/code&gt; to be &lt;code&gt;Mammal*&lt;/code&gt;, but we will see some problems if we do that:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://alschwalm.com/blog/static/content/images/2016/12/2016-12-16-190425_594x341_scrot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Notice that if the real type of &lt;code&gt;m&lt;/code&gt; was &lt;code&gt;Mammal&lt;/code&gt; then the call at line 15 would be to a pure-virtual function. This should never happen. There's also a call to a null pointer at line 17 which would obviously cause issues. So we can conclude that &lt;code&gt;m&lt;/code&gt; must not be a &lt;code&gt;Mammal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This may seem strange, because &lt;code&gt;m&lt;/code&gt; is in fact declared as a &lt;code&gt;Mammal*&lt;/code&gt;. However, that type is the compile-time type (a.k.a., the &lt;em&gt;static type&lt;/em&gt;). We are interested in the &lt;em&gt;dynamic&lt;/em&gt; type (or runtime-type) of &lt;code&gt;m&lt;/code&gt;, because this is what determines which function is called in a virtual function call. In fact, the dynamic type of an object can &lt;em&gt;never&lt;/em&gt; be an abstract type. So if a given &lt;em&gt;vtable&lt;/em&gt; contains one of the &lt;code&gt;___cxa_pure_virtual&lt;/code&gt; functions, then it is not a candidate and you can ignore it. We could have not created a &lt;em&gt;vtable&lt;/em&gt; structure for &lt;em&gt;Mammal&lt;/em&gt; because it will never be used (but I hope seeing why was useful).&lt;/p&gt;

&lt;p&gt;So the dynamic type will be &lt;em&gt;Cat&lt;/em&gt; or &lt;em&gt;Dog&lt;/em&gt;, and we know which functions will be called in either case by looking at their vtable entries. This is the basics of virtual function reverse engineering. In the next part we will go in to how to deal with larger code bases and more complex scenarios.&lt;/p&gt;</content:encoded></item></channel></rss>